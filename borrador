		self.lock_odometry.acquire()	
		if is_debug:
            v = self.v.value
            w = self.w.value
        else:
			# Lectura de los grados de giro de la rueda en un instante
			grMotorR = self.BP.get_motor_encoder(self.BP.PORT_B)
			grMotorL = self.BP.get_motor_encoder(self.BP.PORT_C)
			
			rdMotorR = math.radians(grMotorR)
			rdMotorL = math.radians(grMotorL)
			
			# Tiempo transcurrido entre lecturas
			t_prev = self.encoder_timer
			self.encoder_timer = time.time()
			
			t = self.encoder_timer - t_prev
			
			# Calculo velocidades angulares en cada motor
            wMotorR = (rdMotorR - self.rdMotorR_prev) / t
            wMotorL = (rdMotorL - self.rdMotorL_prev) / t
          
			# Calculo velocidades actuales
            v_w = np.array([[self.radio_rueda / 2, self.radio_rueda / 2],
                            [self.radio_rueda / self.long_ruedas, -self.radio_rueda / self.long_ruedas]
                            ]).dot(np.array([wMotorR, wMotorL]))

			# Actualizacion de variables
			self.rdMotorR_prev = rdMotorR
			self.rdMotorL_prev = rdMotorL
			
            v = v_w[0]
            w = v_w[1]

        self.lock_odometry.release()

        return v, w	
